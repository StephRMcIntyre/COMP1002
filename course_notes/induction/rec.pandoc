---
--from markdown+simple_tables
---

# Induction

## Recursion

### Recursive Definitions

Often-times, problems are solvable by breaking the problem into parts,
then solving the parts, and then combining the individual parts’ solutions.
<br>Sometimes the individual parts’ problems are the same as the original
problem, just smaller. <br>In this case, we call the method _recursive_.

In programming, this is done by having functions that eventually call
themselves to solve sub-problems
<br>In mathematics, this is done by having recursive definitions.

Note: Some books will call it an inductive definition. Either is fine.

A good recursive definition will have:

+ Base Case(s)/Basis
	* These are the smallest items in the recursive set.
	* It is also where the recursion stops.
	* Without this, we typically have infinite recursion, which is not desirable.
	* There can be multiple base cases.
+ Recursion/Recursive Step(s)
	* This details how additional elements are made.
	* There can be multiple recursive steps.

_Note:_ Often there is a "nothing else" clause. Meaning nothing else is that type of structure.
<br>If it is not included, assume it is there implicitly. 

Note we have already seen these!
<br>The syntax/semantics of PL and FOL were recursively defined!

__Example 1: Counting Numbers__

Let the counting numbers be defined recursively as follows:
<br> $~~~~$ 1) 0 is a counting number,
<br> $~~~~$ 2) If n is a counting number, then n+1 is a counting number.

This is an inductive/recursive definition since
<br>  $~~~~$ 1) provides the basis (base case), while
<br>  $~~~~$ 2) provides a way to recursively add more elements to the set of counting numbers.

Example: 0 is a counting number.
<br>Thus 0+1=1 is a counting number.
<br>Thus 1+1=2 is a counting number ....etc. etc.

```{.QualitativeProblem .MultipleSelection options="check" submission="none" content-format="html"}
Counting-Number. Select all of those which are counting numbers.
| --1
| *0
| 5.5
| *1000
```
__Exercise:__ Show by induction that all counting numbers are non-negative.
<br>_Recall, a number is non-negative if it is greater than or equal to 0._

```{.QualitativeProblem .MultipleChoice options="check" submission="none" content-format="html"}
Counting-Number-Exercise1. Select the base case for the Exercise.
| --1
| *0
| 1
| 2
```

```{.QualitativeProblem .MultipleChoice options="check" submission="none" content-format="html"}
Counting-Number-Exercise2. Select the inductive hypothesis for the Exercise.
| Assume 0 is non-negative.
| Assume 1 is non-negative.
| *Assume k is non-negative, where k is greater than or equal to 0.
| Assume k is non-negative, where k is greater than 0.
```

```{.QualitativeProblem .MultipleChoice options="check" submission="none" content-format="html"}
Counting-Number-Exercise3. Select the inductive argument for the Exercise.
| *1>=0+1 by inductive hypothesis. 0+1>0, therefore k+1>=0 and thus is non-negative.
| *k+1>=0+1 by inductive hypothesis. As 0+1>=0, therefore k+1>=0 and thus k+1 is non-negative.
| Since k+1 is non-negative, then k>=0. By the inductive hypothesis, k is non-negative. Therefore k+1 is non-negative.
| *k+1>0+1 by inductive hypothesis. As 0+1>=0, therefore k+1>=0 and thus k+1 is non-negative.
```

__Example 2: Exponentiation__

Let exponentiation $a^n$ for real numbers $a$ and counting numbers $n$ be defined
recursively as follows:
<br> $~~~~$ 1) $a^0$ = 1,
<br> $~~~~$ 2) $a^{k+1}$ = $a^k$ · $a$ for all counting numbers k≥0

```{.QualitativeProblem .MultipleSelect options="check" submission="none" content-format="html"}
Exponentiation1. Select all of the numbers generated by the exponentation definition when $a=2$.
| 0
| *1
| *2
| *16
| 28
```

Using the recursive definition for exponentiation and the Associative Laws for addition and multiplication, prove the law of exponents $a^m$ · $a^n$ = $a^{m+n}$,
where $a$ is a real number and both $m$ and $n$ are counting numbers.

```{.QualitativeProblem .MultipleChoice options="check" submission="none" content-format="html"}
Exponentiation2. Select the base case/basis for the proof we are about to do.
| a = 2, m = 0, n = 0.
| 1
| *arbitrary a, arbitrary m, induction on n.
| a=2, arbitrary m, induction on n.
```

__Proof:__ Suppose a is any real number and m is any counting number.
<br>For such an a and m, we’ll prove the law for any counting number n by mathematical induction.
<br>__Base case (n=0):__ $a^m$ · $a^0$ = $a^m$ · 1, by Exponentiation definition part 1
<br>$~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~$ = $a^m$, as x1=x for all x.
<br>__Induction Hypothesis:__ Suppose $a^m$ · $a^k$ = $a^{m+k}$ for k≥0.
<br>__Inductive Argument:__ We want to prove that $a^m$ · $a^{k+1}$ = $a^{m+(k+1)}$.
<br> $a^m$ · $a^{k+1}$ = $a^m$ · ($a^k$ · $a$), by Exponentiation definition part 2 (k≥0, therefore k+1>0)
<br>$~~~~~~~~~~~~~~~~~~$ = ($a^m$ · $a^k$) · $a$, by Associativity of multiplication
<br>$~~~~~~~~~~~~~~~~~~$ = $a^{m+k}$ · $a$, by Inductive Hypothesis as $a^m$ · $a^k$ = $a^{m+k}$.
<br>$~~~~~~~~~~~~~~~~~~$ = $a^{(m+k)+1}$, by Exponentiation definition part 2 (k≥0, therefore k+1>0)
<br>$~~~~~~~~~~~~~~~~~~$ = $a^{m+(k+1)}$, by Associativity of addition.
<br>__Conclusion:__ Therefore, $a^m$ · $a^n$ = $a^{m+n}$ for all counting numbers $n$ by the principle of induction.
<br>Since $a$ and $m$ are arbitrary, the conclusion holds for any real number $a$ and any counting numbers $m$ and $n$ by Universal Generalization.

__Example 3: Simple Prop Wffs__

A recursive definition gives a set of objects which share that type.

Let the set of simple propositional wffs be recursively defined as follows:
<br> $~~~~$ 1) P, where P is __any__ proposition symbol, is a simple propositional wff.
<br> $~~~~$ 2) If α is a simple propositional wff, then so is (¬α).
<br> $~~~~$ 3) If α and β are both simple propositional wffs, then so is (α ∧ β).
<br> $~~~~$ 4) If α and β are both simple propositional wffs, then so is (α ∨ β).

For example, (¬P) would be a simple propositional wff, but ¬P would not as it is missing the parentheses.

```{.QualitativeProblem .MultipleSelection options="check" submission="none" content-format="html"}
SimplePropWffs1. Select all of the elements in the set of simple propositional wffs.
| *R
| (P ∧ Q) ∨ S
| *((P ∧ Q) ∨ (¬S))
| (P)
| *(¬(P ∧ Q))
| (P → P)
```
_Hint: It must be constructed exactly as given in the definition. Construct them on paper following the rules._

```{.QualitativeProblem .MultipleSelection options="check" submission="none" content-format="html"}
SimplePropWffs2. Select all of the elements in the basis for simple propositional wffs.
| *R
| (P ∧ Q) ∨ S
| ((P ∧ Q) ∨ (¬S))
| (P)
| (¬(P ∧ Q))
| *P
```

```{.QualitativeProblem .MultipleSelection options="check" submission="none" content-format="html"}
SimplePropWffs3. Select all of the clauses which are part of the recursion step for simple propositional wffs.
| P, where P is __any__ proposition symbol, is a simple propositional wff.
| *If α is a simple propositional wff, then so is (¬α).
| *If α and β are both simple propositional wffs, then so is (α ∧ β).
| *If α and β are both simple propositional wffs, then so is (α ∨ β).
```

Derive ((P ∧ Q) ∨ (¬S)).
<br> $~~~~$ By the basis, P, Q and S are all simple propositional wffs.
<br> $~~~~$ Since P and Q are simple propositional wffs, then by 3) (P ∧ Q) is a simple propositional wff.
<br> $~~~~$ As S is a simple propositional wff, then by 2) so is (¬S).
<br> $~~~~$ Lastly, as both (P ∧ Q) and (¬S) are simple propositional wffs, then by 4) so is ((P ∧ Q) ∨ (¬S)).

<br><br><br>
####Exercises

__Exercise:__ Derive (¬((¬Q) ∨ (¬(¬S)))).

__Exercise:__ Using the definition of exponentiation, prove it is not the case that for all real numbers $a$ and counting numbers $m$,$n$ that $a^{m+n}$≥$0$

__Exercise:__ Using the definition of exponentiation, prove it is not the case that for any counting number $m$, $-1^{m}$ ≥ $1^{m}$

__Exercise:__ Using the definition of exponentiation, show by induction for any counting number $m$, $1^{m}$ ≥ $-1^{m}$.

<p>[Previous: Sequences Practice Problems](https://carnap.io/shared/srenee651@gmail.com/oops) &emsp; &emsp; &emsp; &emsp; [-Main Page-](https://carnap.io/assignments/COMP%201002%20-%20Spring%202022/Workbook.pandoc#part-iii-induction)   &emsp; &emsp; &emsp; &emsp;  [Next: Recurrence Relations](https://carnap.io/shared/srenee651@gmail.com/book-induction-recrel.pandoc) </p>

